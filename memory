# 内存设计 (bios)
0xFFFF0     CPU 加电瞬间执行的位置，CS=0xF000，IP=0xFFF0。
0xFFFE
            加载了 8KB 左右与中断向量表对应的若干中断程序。
0xE05B
0x83FF
            每块内存的详细信息，每个信息块 20 字节。
0x8202
0x8201
            记录检测到的内存块数。
0x8200
0x81FF
            setup.asm 程序在内存中的位置（1024字节）。
0x7E00
0x7DFF
            boot.asm (size = 512B = 0x200B)。
0x7C00
0x7BFF
            boot 及 setup 程序所用栈区。
0x500
0x4FF
            bios 数据区，256 字节。
0x400
0x3FF
            中断向量表，256 个中断向量，每个中断向量占用 4B。
0x000


# 内存设计（内核）
...
    get_free_page管理的内存，其中前两页管理了物理页表map。
0x100000
0xFFFFF
    主板BIOS、显卡BIOS等只读区域。（不可覆盖内存）
0xC0000
0xBFFFF
    文本模式显示适配器。（不可覆盖内存）
0xB8000
0xB7FFF
    黑白显示适配器。（不可覆盖内存）
0xB0000
0xAFFFF
    彩色显示适配器。（不可覆盖内存）
0xA0000     内核栈顶
0x4400
    内核程序加载位置。
0x0000

# 进程虚拟内存映射
不同于物理内存，进程虚拟内存是被映射到物理内存上的，在开启分页后，我们访问的虚拟内存会通过 MMU 来访问实际的物理内存。
关于虚拟内存是如何映射到物理内存的参考如下。
需要说明：如果访问的虚拟内存没有被映射到物理内存，则会导致页面缺失中断。
|----------------------------------------------------------------------|-------------------------|----------------------|
|                                                                      |     virtual memory      |    physical memory   |
|----------------------------------------------------------------------|-------------------------|----------------------|
|                                                                      |                         |                      |
|          low area is mapped into true physical memory                |                         |                      |
|    that means if we truly visit memory between 0x000 and 0xFFFFF     |  (0x00000 ~ 0xFFFFF)    | (0x00000 ~ 0xFFFFF)  |
|         we will truly visit physical memory 0x000 - 0xFFFFF          |                         |                      |
|                                                                      |                         |                      |
|----------------------------------------------------------------------|-------------------------|----------------------|